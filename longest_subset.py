""""
Для начала рассмотрим неоптимальный алгоритм.

Этот алгоритм неделает ничего умного — он простос читает каждое число числовым, пытаясь
отсчитать как можно больше от этого числа, используя только числовое число.
После того, как он подсчитает слишком много(т.е.currentNum относится к числу, которого nums
не содержит), он записывает длину последовательности, если она больше, чем текущий лучший результат.

Наш же оптимизированный алгоритм содержит только два изменения по сравнению с подходом неоптимального
алгоритма: числа хранятся в HashSet(или Set в Python), чтобы разрешить поиск O(1), и мы
пытаемся построить последовательности только из чисел, которые
еще не часть более длинной последовательности.
Для этого сначала необходимо убедиться, что номер, который непосредственно предшествует текущему номеру
в последовательности, отсутствует, поскольку этот номер обязательно будет частью
более длинной последовательности.
"""

def Solution(nums):
    longest_streak = 0
    num_set=set(nums)
    for num in num_set:
       if num-1 not in num_set:
           current_num=num
           current_streak=1
           while current_num+1 in num_set:
               current_num+=1
               current_streak+=1
           longest_streak=max(longest_streak, current_streak)
    return longest_streak
nums=list(map(int,input().split())) #1004200132
print(Solution(nums)) #4